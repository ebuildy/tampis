#!/usr/bin/env python3

from jinja2 import Environment
from jinja2.loaders import FileSystemLoader

import datetime
import argparse
import yaml
import os
import textwrap


#
# Parse requirements YAML file.
#
def parse_deps(path):
    with open(os.path.join(path, "requirements.yaml"), 'r') as stream:
        data = yaml.load(stream, Loader=yaml.FullLoader)

        return [x["name"] for x in data['dependencies']]

#
# Discover env list.
#
def parse_envs(path):
    return os.listdir(os.path.join(path, "config"))

def process(root_path, env, deps):
    generated_data = {}

    with open(os.path.join(root_path, "config", env, "data.yaml"), 'r') as stream:
        data = yaml.load(stream, Loader=yaml.FullLoader)

        for dep in deps:
            env = Environment(loader=FileSystemLoader('.'))

            templateEngine = env.get_template(os.path.join(root_path, "values", f"{dep}.yaml"))

            generated_data[dep] = templateEngine.render(data)

    return generated_data


def main():
    parser = argparse.ArgumentParser(description='Generate composed chart values.')
    parser.add_argument('path', type=str,
                       help='The YAML data file path')

    args = parser.parse_args()

    deps = parse_deps(args.path)
    envs = parse_envs(args.path)

    for env in envs:
        generated_data = process(args.path, env, deps)

        with open(os.path.join(args.path, f"values-{env}.yaml"), 'w+') as stream:
            stream.write(f"#\n## Generated by Tampis, at {datetime.datetime.now()}\n")
            stream.write(f"## env = {env} , deps = {deps}\n#\n\n")

            for dep in deps:
                stream.write(f"\n# dep = {dep} \n")
                stream.write(f"{dep}:\n")
                stream.write(textwrap.indent(generated_data[dep], 4 * ' '))
                stream.write("\n")

if __name__ == "__main__":
    main()
